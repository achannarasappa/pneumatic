// Functions that operate on slices
//
// Usage Notes
//
//  • arity - all functions have a arity of two wherein the function is prepared with all arguments in the first call and the input data is applied in the second call
package slice

// Map applies an iterator function to each element in a slice and returns a slice with the new elements
//
// Parameters
//
//  • iterator: function that's applied to each element
//  • data:     slice of elements
//
// Return Value
//
//  • result:   slice of elements with the iterator applied
//
func Map[TValue any, TResult any](iterator func(TValue) TResult) func([]TValue) []TResult {
	return func(data []TValue) []TResult {
		out := make([]TResult, len(data))
		for i, v := range data {
			out[i] = iterator(v)
		}
		return out
	}
}

// MapIndexed is the same as Map but also makes the index and input elements available to the iterator function
//
// Parameters
//
//  • iterator: function that's applied to each element
//  • data: list of elements
//
// Return Value
//
//  • result: list of elements with the iterator applied
//
func MapIndexed[TValue any, TResult any](iterator func(TValue, int, []TValue) TResult) func([]TValue) []TResult {
	return func(data []TValue) []TResult {
		out := make([]TResult, len(data))
		for i, v := range data {
			out[i] = iterator(v, i, data)
		}
		return out
	}
}

// Reduce iterates over a slice and calls the iterator function on each element while passing the accumulator to the next call
//
// Parameters
//
//  • iterator: function that's applied to each element
//  • data: list of elements
//
// Return Value
//
//  • result: the list of elements reduced to a single data type
//
func Reduce[TValue any, TAcc any](iterator func(TAcc, TValue, int) TAcc, initialAcc TAcc) func([]TValue) TAcc {
	return func(data []TValue) TAcc {
		out := initialAcc
		for i, v := range data {
			out = iterator(out, v, i)
		}
		return out
	}
}