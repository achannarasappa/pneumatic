// Functions that operate on slices
//
// Usage Notes
//
//  • arity - all functions have a arity of two wherein the function is prepared with all arguments in the first call and the input data is applied in the second call
package slice

// Map applies an iterator function to each element in a slice and returns a slice with the new elements
//
// Parameters
//
//  • iterator: function that's applied to each element
//  • data:     slice of elements
//
// Return Value
//
//  • result:   slice of elements with the iterator applied
//
func Map[TValue any, TResult any](iterator func(TValue) TResult) func([]TValue) []TResult {
	return func(data []TValue) []TResult {
		out := make([]TResult, len(data))
		for i, v := range data {
			out[i] = iterator(v)
		}
		return out
	}
}

// MapIndexed is the same as Map but also makes the index and input elements available to the iterator function
//
// Parameters
//
//  • iterator: function that's applied to each element
//  • data: list of elements
//
// Return Value
//
//  • result: list of elements with the iterator applied
//
func MapIndexed[TValue any, TResult any](iterator func(TValue, int, []TValue) TResult) func([]TValue) []TResult {
	return func(data []TValue) []TResult {
		out := make([]TResult, len(data))
		for i, v := range data {
			out[i] = iterator(v, i, data)
		}
		return out
	}
}

// Reduce iterates over a slice and calls the iterator function on each element while passing the accumulator to the next call
//
// Parameters
//
//  • iterator: function that's applied to each element
//  • data: list of elements
//
// Return Value
//
//  • result: the list of elements reduced to a single data type
//
func Reduce[TValue any, TAcc any](iterator func(TAcc, TValue, int) TAcc, initialAcc TAcc) func([]TValue) TAcc {
	return func(data []TValue) TAcc {
		out := initialAcc
		for i, v := range data {
			out = iterator(out, v, i)
		}
		return out
	}
}

// Filter calls the predicate function on each element and removes those elements that do not satisfy the predicate
//
// Parameters
//
//  • predicate: function that is called against each element
//  • data: list of elements
//
// Return Value
//
//  • result: list of elements where the predicate is not satisfied
//
func Filter[TValue any](predicate func(TValue) bool) func([]TValue) []TValue {
	return func(data []TValue) []TValue {
		out := make([]TValue, 0)
		for _, v := range data {
			if predicate(v) {
				out = append(out, v)
			}
		}
		return out
	}
}

// Reject calls the predicate function on each element and removes those elements that do satisfy the predicate
//
// Parameters
//
//  • predicate: function that is called against each element
//  • data: list of elements
//
// Return Value
//
//  • result: list of elements where the predicate is satisfied
//
func Reject[TValue any](predicate func(TValue) bool) func([]TValue) []TValue {
	return func(data []TValue) []TValue {
		out := make([]TValue, 0)
		for _, v := range data {
			if !predicate(v) {
				out = append(out, v)
			}
		}
		return out
	}
}

// GroupBy creates a map where the key is a group identifier and the value is a slice with the elements that have the same identifer
//
// Parameters
//
//  • grouper: function receives each element and returns a string identifier for the element
//  • data: list of elements
//
// Return Value
//
//  • result: map of elements grouped by identifiers
//
func GroupBy[TValue any](grouper func(TValue) string) func([]TValue) map[string][]TValue {
	return func(data []TValue) map[string][]TValue{
		var id string
		out := make(map[string][]TValue)
		for _, v := range data {
			id = grouper(v)
			out[id] = append(out[id], v)
		}
		return out
	}
}