package slice_test

import (
	"reflect"
	"strconv"
	"strings"
	"testing"

	s "github.com/achannarasappa/pneumatic/slice"
)

type TestCase struct {
	description string
	input       interface{}
	output      interface{}
	expected    interface{}
}

type Element1 struct {
	Key   string
	Value string
}

type Element2 struct {
	Token string
}

func TestMap(t *testing.T) {

	tests := []TestCase{
		{
			description: "It should map over a slice of ints",
			output:      s.Map(func(v int) int { return v * 2 })([]int{1, 2, 3}),
			expected:    []int{2, 4, 6},
		},
		{
			description: "It should map over a slice of strings",
			output:      s.Map(strings.ToLower)([]string{"Test1", "Test2", "Test3"}),
			expected:    []string{"test1", "test2", "test3"},
		},
		{
			description: "It should map over a slice of structs",
			output: s.Map(func(v Element1) Element2 { return Element2{Token: v.Key + "-" + v.Value} })([]Element1{
				{
					Key:   "k1",
					Value: "v1",
				},
				{
					Key:   "k2",
					Value: "v2",
				},
			}),
			expected: []Element2{
				{
					Token: "k1-v1",
				},
				{
					Token: "k2-v2",
				},
			},
		},
	}

	for _, test := range tests {
		if !reflect.DeepEqual(test.output, test.expected) {
			t.Errorf("\n\n%s\n\nOutput: %v\nExpected: %v\n\n", test.description, test.output, test.expected)
		}
	}
}

func TestMapIndexed(t *testing.T) {

	tests := []TestCase{
		{
			description: "It should map over a slice of strings and access the index",
			output:      s.MapIndexed(func(v string, i int, l []string) string { return v + strconv.Itoa(i) })([]string{"test", "test", "test"}),
			expected:    []string{"test0", "test1", "test2"},
		},
	}

	for _, test := range tests {
		if !reflect.DeepEqual(test.output, test.expected) {
			t.Errorf("\n\n%s\n\nOutput: %v\nExpected: %v\n\n", test.description, test.output, test.expected)
		}
	}
}

func TestReduce(t *testing.T) {

	tests := []TestCase{
		{
			description: "It should iterate over a slice of ints and sum them up",
			output:      s.Reduce(func(acc int, v int, _ int) int { return acc + v })([]int{10, 30, 60}),
			expected:    100,
		},
	}

	for _, test := range tests {
		if !reflect.DeepEqual(test.output, test.expected) {
			t.Errorf("\n\n%s\n\nOutput: %v\nExpected: %v\n\n", test.description, test.output, test.expected)
		}
	}
}
